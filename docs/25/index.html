<!DOCTYPE html>

<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>晨旭Lua系列入门教程 [ Luat doc 社区文章静态页面 ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
<meta name="generator" content="Hexo 5.3.0"></head>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="https://iot.openluat.com/assets/img/logo.jpg"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">首页</a>
        
          
          
          
          
          
          
          <a href="/archives">归档</a>
        
          
          
          
          
          
          
          <a href="https://doc.luatos.wiki/wiki/">关于</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">晨旭Lua系列入门教程</h1>
<article class="post markdown-style">
  <h1 id="第一期-下载调试工具LuaTools的使用指南"><a href="#第一期-下载调试工具LuaTools的使用指南" class="headerlink" title="第一期 下载调试工具LuaTools的使用指南"></a>第一期 下载调试工具LuaTools的使用指南</h1><h4 id="1-下载LuaTools工具"><a href="#1-下载LuaTools工具" class="headerlink" title="1 下载LuaTools工具"></a>1 下载LuaTools工具</h4><p><a href="#title1.1">1.1 2G模块烧写教程（Air2xx系列、Air8xx系列）：</a></p>
<p><a href="#title1.2">1.2 刷入AT版本的lod</a></p>
<p><a href="#title1.3">1.3 刷入luat版本的lod</a></p>
<p><a href="#title1.4">1.4 下载lua脚本文件</a></p>
<p><a href="#title1.5">1.5 4G模块烧写教程（Air7xx系列）：</a></p>
<p><a href="#title1.6">1.6 安装驱动</a></p>
<p><a href="#title1.7">1.7 下载AT版本的固件</a></p>
<p><a href="#title1.8">1.8 下载LUAT底层固件</a></p>
<p><a href="#title1.9">1.9 烧录脚本文件</a></p>
<h4 id="2-控制LED小灯"><a href="#2-控制LED小灯" class="headerlink" title="2 控制LED小灯"></a>2 控制LED小灯</h4><p><a href="#title2.1">2.1 准备一个代码编辑器</a></p>
<p><a href="#title2.2">2.2 模块化编程</a></p>
<p><a href="#title2.3">2.3 连接硬件</a></p>
<p><a href="#title2.4">2.4 点亮LED小灯</a></p>
<p><a href="#title2.5">2.5 让LED灯闪烁起来</a></p>
<h4 id="3-LUAT程序的基本时序"><a href="#3-LUAT程序的基本时序" class="headerlink" title="3 LUAT程序的基本时序"></a>3 LUAT程序的基本时序</h4><p><a href="#title3.1">3.1 简单定时器函数的使用</a></p>
<p><a href="#title3.2">3.2 协程</a></p>
<p><a href="#title3.3">3.3 程序注册</a></p>
<h4 id="4-学会使用并看懂luatools的trace信息"><a href="#4-学会使用并看懂luatools的trace信息" class="headerlink" title="4 学会使用并看懂luatools的trace信息"></a>4 学会使用并看懂luatools的trace信息</h4><p><a href="#title4.1">4.1 trace的几个基本部分</a></p>
<p><a href="#title4.2">4.2 自定义输出trace（LuaTask格式）</a></p>
<p><a href="#title4.3">4.3 语法错误输出</a></p>
<h4 id="5-socket代码详解"><a href="#5-socket代码详解" class="headerlink" title="5 socket代码详解"></a>5 socket代码详解</h4><p><a href="#title5.1">5.1 Socket(TCP/UDP)</a></p>
<p><a href="#title5.2">5.2 代码详解（LuaTask格式）</a></p>
<p><a href="#title5.3">5.3 完整代码</a></p>
<p><a href="#title5.4">5.4 验证功能</a></p>
<h4 id="6-mqtt代码详解"><a href="#6-mqtt代码详解" class="headerlink" title="6 mqtt代码详解"></a>6 mqtt代码详解</h4><p><a href="#title6.1">6.1 先定义一个假装能用来测试的mqtt需求</a></p>
<p><a href="#title6.2">6.2 建立Lua文件</a></p>
<p><a href="#title6.3">6.3 完整代码</a></p>
<p><a href="#title6.4">6.4 实现协议需求</a></p>
<h4 id="7-串口收发"><a href="#7-串口收发" class="headerlink" title="7 串口收发"></a>7 串口收发</h4><p><a href="#title7.1">7.1 官方demo代码</a></p>
<p><a href="#title7.2">7.2 先定义一个假装能用来测试的串口收发规则</a></p>
<p><a href="#title7.3">7.3 建立文件结构</a></p>
<p><a href="#title7.4">7.4 实现功能</a></p>
<p><a href="#title7.5">7.5 处理串口数据截断问题</a></p>
<p><a href="#title7.6">7.6 完整代码</a></p>
<p><a href="#title7.7">7.7 最终测试</a></p>
<p>本来是想直接开始写脚本的hello world的教程，但是发现和多人从最基本的烧程序都不知道从何入手，官网给的资料也并不多（我在刚用的时候也卡在这里很久），所以就单独出一期LuaTools的使用教程。<br><a href="#title1"></a></p>
<h2 id="下载LuaTools工具"><a href="#下载LuaTools工具" class="headerlink" title="下载LuaTools工具"></a>下载LuaTools工具</h2><p>下载工具一般要经过以下步骤：</p>
<p>打开合宙官网：<a target="_blank" rel="noopener" href="http://www.openluat.com/">http://www.openluat.com/</a><br>选择上面的“产品中心”，随便选一个产品，如：Air202 GPRS 通信模块<br>点击模块介绍那边的“资料下载”选项卡<br>点击“[LuaTools] Luat下载调试工具x.x.x”下载<br>当然，如果嫌麻烦，直接打开下面链接下载吧。。</p>
<p>下载后可能会进行自动升级，这个工具基本上是持续使用，都不会出现版本过旧的问题 （截止发稿Luatools最新版本为1.7.24）<br><img src="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001241028_attachments-2018-08-CJ5id45L5b7eaeb7523b0.png" alt="alt"><br>↑软件界面<br><a href="#title2"></a></p>
<h2 id="2G模块烧写教程（Air2xx系列、Air8xx系列）："><a href="#2G模块烧写教程（Air2xx系列、Air8xx系列）：" class="headerlink" title="2G模块烧写教程（Air2xx系列、Air8xx系列）："></a>2G模块烧写教程（Air2xx系列、Air8xx系列）：</h2><p>（4G模块烧录方法请看往下翻，看下一部分）</p>
<p>这时候，我们只需要用usb转串口线，与给模块/开发板的HOST串口相连，GND相连，并给模块上点即可</p>
<pre><code>注意：模块的HOST口使用的是921600波特率，如果你使用的是劣质串口芯片（如质量差的pl2303以及山寨的ch340之类的），会出现无法通讯的现象。并且需要保证模块供电充足，不然会出现无限重启的状况。
</code></pre>
<h3 id="下载lod固件文件-更改AT和luat底层版本"><a href="#下载lod固件文件-更改AT和luat底层版本" class="headerlink" title="下载lod固件文件/更改AT和luat底层版本"></a>下载lod固件文件/更改AT和luat底层版本</h3><p>lod文件相当于一个模块的底层部分，lod文件可以分为AT版与luat版</p>
<p>AT版只能使用AT命令对模块进行控制，AT串口为uart1口<br>luat版为运行lua脚本所使用的底层，可对模块内部进行片内编程，完成一部分或全部的本应由外接单片机完成的工作</p>
<h3 id="刷入AT版本的lod"><a href="#刷入AT版本的lod" class="headerlink" title="刷入AT版本的lod"></a>刷入AT版本的lod</h3><p><img src="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001402829_attachments-2018-08-0bO65Rpw5b7eaee4001e1.png" alt="alt"><br>刷入AT版本的固件十分简单，在上面连接模块完成之后，确保串口选项卡的串口为你设备的串口值，点击菜单中的AT–切换为标准的AT版本，如下图：</p>
<p>点击下载为模块烧入AT固件：<br><img src="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001439626_attachments-2018-08-YoR7nKRd5b7eaf4e48f99.png" alt="alt">![alt](<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001535502_attachments-2018-08-YPmuTKwZ5b7eaf06b4f37.png">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001535502_attachments-2018-08-YPmuTKwZ5b7eaf06b4f37.png</a><br>这样，AT版本固件的lod就烧录完成了。<br><a href="#title3"></a></p>
<h3 id="刷入luat版本的lod"><a href="#刷入luat版本的lod" class="headerlink" title="刷入luat版本的lod"></a>刷入luat版本的lod</h3><p>luat的固件因为需求不同，所以为了节省空间，提供了多种库的组合<br>luat的固件可以在下载工具目录的/LuaTools x.x.x/8955Lod/找到，每个版本的区别可以参考readme.txt文件中的描述，部分内容也贴在下面：</p>
<pre><code>Luat_VXXXX_8955.lod：不支持SSL、TTS、SPI接口的LCD功能
Luat_VXXXX_8955_SSL.lod：支持SSL功能
Luat_VXXXX_8955_SSL_TTS.lod：支持SSL、TTS功能，不支持MP3、MIDI、录音功能
Luat_VXXXX_8955_SSL_UI.lod：支持SSL、SPI接口的LCD功能
Luat_VXXXX_8955_TTS_UI.lod：支持TTS、SPI接口的LCD功能
Luat_VXXXX_8955_TTS1.lod：支持TTS功能
Luat_VXXXX_8955_TTS2.lod：支持TTS功能、不支持MP3、MIDI、录音、json
Luat_VXXXX_8955_UI.lod：支持SPI接口的LCD功能
Luat_VXXXX_8955_SSL_FLOAT.lod：支持SSL功能、浮点数
Luat_VXXXX_8955_SSL_UI_FLOAT.lod：支持SSL功能、PI接口的LCD功能、浮点数
Luat_VXXXX_8955F.lod：64M flash版本（Air202F），支持SSL、TTS、SPI接口的LCD功能
</code></pre>
<p>我以烧录最基本的Luat_VXXXX_8955.lod为例，首先在调试工具中确保串口选项卡的串口为你设备的串口值，点击下载LOD(core)按钮，选中之前在工具目录的lod文件：<br>)![alt](<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001640169_attachments-2018-08-UI7Ip9Yl5b7eaf14a2596">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001640169_attachments-2018-08-UI7Ip9Yl5b7eaf14a2596</a>.<br>选中确认无误后，点击下载进行写入lod的操作<br>png)<img src="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001750895_attachments-2018-08-YoR7nKRd5b7eaf4e48f99.png" alt="alt"><br><img src="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219001857605_attachments-2018-08-Hql1h9uA5b7eaf5545a62.png" alt="alt"><br>上面下载失败了，要重新下载一遍<br>###下载lua脚本文件</p>
<p>由于luat模块的特色就是lua二次开发，所以下载烧录脚本的方法也是必须掌握的，下面以烧录S9开发板的示例程序为例(S9就是那个板载usb的开发板)</p>
<p>lib库已在luatools中自带，无需再自己下载</p>
<h3 id="烧录S9需要的底层lod文件"><a href="#烧录S9需要的底层lod文件" class="headerlink" title="烧录S9需要的底层lod文件"></a>烧录S9需要的底层lod文件</h3><p>S9需要的底层lod是Luat_VXXXX_8955_UI.lod，这里的UI库包含了字库和各种SPI、I2C屏幕的驱动<br>烧录步骤不再重复，请确保烧录最后成功了<br>烧录lua脚本</p>
<p>lua脚本分为两部分：一个部分是官方写的lib库文件（library），另一部分是用户自己的脚本文件。一般lib的文件不用去修改，除非有特殊需求。</p>
<pre><code>lua库分为两个版本：
一个是老的script，
另一个是由稀饭放姜进行编写的script_LuaTask库

新项目都用script_LuaTask进行编写；老用户使用了script编写的，如码夫支付模块，可以继续用老版本，没有任何影响。
</code></pre>
<p>这里烧录的S9开发板就是使用的script_LuaTask进行编写的，具体步骤如下：</p>
<p>点击下载lua脚本按钮，将文件列表全部清空：<br>![alt](<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219002050281_attachments-2018-09-DIs4Ap8Z5b9b64f9e550e_QQ%E6%88%AA%E5%9B%BE20180914153616">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219002050281_attachments-2018-09-DIs4Ap8Z5b9b64f9e550e_QQ截图20180914153616</a>.<br>点击添加脚本，将刚刚从git仓库下载的Luat_2G_RDA_8955/script_LuaTask/product/LuatBoard_Air202/demo下的所有文件全部选中，点击打开确认选中</p>
<pre><code>这里如果没有选择lib文件，工具会自动进行提示
</code></pre>
<p>点击下载，会弹出对话框让你补全lib库文件，这里我们选择“优先推荐”的LuaTask库，点击确定：<br>png)<img src="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219002223864_attachments-2018-08-3rV4WVgP5b7eaf905eec1.png" alt="alt"><br>最后，等待下载成功即可<br>![alt](<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219002540439_attachments-2018-09-F81NV54U5b9b65a8806a1_QQ%E6%88%AA%E5%9B%BE20180914153841.p">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219002540439_attachments-2018-09-F81NV54U5b9b65a8806a1_QQ截图20180914153841.p</a><br>关闭对话框，即可看到设备运行的trace信息，这个信息可能会在下一章进行解释：<br>ng)<img src="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219002630258_attachments-2018-08-tnZsYZc95b7eafbeb0c92.png" alt="alt"><br>##4G模块烧写教程（Air7xx系列）：</p>
<p>这里我们使用Air720开发板（S720 Border）作为演示，首先需要将开发板按如下方式连接电脑：<br><img id="portrait" src=http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200219201026352_attachments-2018-09-Fqsh4Frw5b9b543197651_QQ图片20180914142039.png></img></p>
<p>连接后，我们会在设备管理器看到有几个未安装的驱动，我们需要安装上这些驱动</p>
<h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><pre><code>&lt;img id=&quot;portrait&quot; src=http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221012058993_attachments-2018-09-OcuKrp1S5b9b596995edb_QQ截图20180914144646.png&gt;&lt;/img&gt;
对于win8/win8.1/win10电脑，在安装驱动前需要进行如下操作（win7可以跳过该部分直接安装驱动）：
win8：在桌面右侧点击弹出菜单中的“设置”，点击“更改电脑配置”，在左侧点击“通用”，接着点击右侧“高级启动”中的“立刻重启”按钮
win10：按下win+i快捷键，点击“更新和安全”—“恢复”—“高级启动”下的“立即重启”按钮

接着就进入了高级启动界面，选择“疑难解答”—“高级选项”—“启动设置”—“重启”
在启动设置页按F7选择禁用驱动强制数字签名，就可以在该模式下开机了。
</code></pre>
<p>我们可以在<a target="_blank" rel="noopener" href="http://www.openluat.com/Product/4g/Air720D.html%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B5%84%E6%96%99%E4%B8%8B%E8%BD%BD%EF%BC%8C%E4%B8%8B%E8%BD%BD[%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F]">http://www.openluat.com/Product/4g/Air720D.html页面的资料下载，下载[驱动程序]</a> AirM2M_USB_Download&amp;Com_Driver_for_4G_V1.0</p>
<p>安装压缩包中的驱动。注意，32位与64位驱动不同，请根据自己电脑选好安装包exe<br>安装过程中肯定会弹出下面的窗口，点击始终安装即可<br><img id="portrait" src=http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221012324920_attachments-2018-09-whEUtOjF5b9b59a5bf0e1_QQ截图20180914144749.png></img><br>安装成功后，将板子重新连接即可。</p>
<h3 id="下载AT版本的固件"><a href="#下载AT版本的固件" class="headerlink" title="下载AT版本的固件"></a>下载AT版本的固件</h3><pre><code>注意：AT固件也可以直接通过AT指令来进行远程升级，无需使用LuaTools工具，详情请参阅http://oldask.openluat.com/article/186

如果是模块飞线烧录，请先确保可以保证模块的稳定供电，并且烧录时模块不会被重启，按下图进行飞线usb：
</code></pre>
<p>img id=”portrait” src=<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221012509038_5_51295.jpg&gt;">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221012509038_5_51295.jpg&gt;</a></img><br>打开luatools，将在菜单栏切换为4G模式：</p>
<p>直接点击AT–升级到标准AT版本即可，点击下载：</p>
<p>src=<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221012712634_attachments-2018-08-5cy7CJI85b7eafcd118f8.png&gt;">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221012712634_attachments-2018-08-5cy7CJI85b7eafcd118f8.png&gt;</a></img><br>这时工具会进入下载模块，我们可以点击开发板上的“重启”按键，或者开关旁边的拨码开关，下载工具会自动开始下载：</p>
<p>烧录后，我们可以用串口工具，通过虚拟的AT串口来进行AT操作：</p>
<p>同时，也可以从开发板的另一个usb引脚，将拨码改至UART2，进行AT控制：</p>
<h3 id="下载LUAT底层固件"><a href="#下载LUAT底层固件" class="headerlink" title="下载LUAT底层固件"></a>下载LUAT底层固件</h3><p>打开luatools，将在菜单栏切换为4G模式：<br>img id=”portrait” src=<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221020312010_attachments-2018-09-LfNmMIl85b9b5f5070499_QQ%E6%88%AA%E5%9B%BE20180914151206.png&gt;">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221020312010_attachments-2018-09-LfNmMIl85b9b5f5070499_QQ截图20180914151206.png&gt;</a></img><br>首先要先烧录blf底层文件，点击右上角的下载CORE，<br>选择需要烧入的底层文件（可在LuaTools x.x.x\asr1802\CORE\Luat_V0005_ASR1802\文件夹找到），点击下载：<br><img id="portrait" src=http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221020821228_attachments-2018-09-HDGMkxxe5b9b600493762_QQ截图20180914151508.png></img><br>这时工具会进入下载模块，我们可以点击开发板上的“重启”按键，或者开关旁边的拨码开关，下载工具会自动开始下载：<br>img id=”portrait” src=<a target="_blank" rel="noopener" href="http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221020928102_attachments-2018-09-PfYPshpL5b9b6076c12ef_QQ%E6%88%AA%E5%9B%BE20180914151701.png&gt;">http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221020928102_attachments-2018-09-PfYPshpL5b9b6076c12ef_QQ截图20180914151701.png&gt;</a></img><br><img id="portrait" src=http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221021012967_attachments-2018-09-UHFzxvQC5b9f0e8be9b41_QQ截图20180917101617.png></img></p>
<p>底层烧录完成。</p>
<h3 id="烧录脚本文件"><a href="#烧录脚本文件" class="headerlink" title="烧录脚本文件"></a>烧录脚本文件</h3><p>我们用demo文件夹中的adc举例，烧录一个完整的脚本工程<br>（如果需要新建项目，千万不要在luatool下建立项目文件夹，不然会在更新时被删掉）<br>点击下载lua脚本，先点击打开4G（.blf）文件按钮，选择之前烧录的底层文件<br>然后点击清空所有：<br><img id="portrait" src=http://openluat-luatcommunity.oss-cn-hangzhou.aliyuncs.com/images/20200221021152009_attachments-2018-09-DIs4Ap8Z5b9b64f9e550e_QQ截图20180914153616.png></img><br>接着点击添加脚本我们把LuaTools x.x.x\asr1802\lib\demo\adc文件夹下的所有文件添加进去，点击下载脚本<br><img src="http://oldask.openluat.com/file/attachments-2018-09-ZXaS33xT5b9b65294c113_QQ%E6%88%AA%E5%9B%BE20180914153702.png" alt="alt"><br>这是会由于没有添加lib文件夹内的lua库文件而弹出一个对话框，我们直接点击确定，自动补全即可：<br>（如果没补全，那就手动把lib文件夹的所有文件都加进去）<br><img src="http://oldask.openluat.com/file/attachments-2018-09-QVbeorMP5b9b6495a6c41_QQ%E6%88%AA%E5%9B%BE20180914153437.png" alt="alt"><br>接着就和上面烧录固件一样了，点击开发板上的重启按键，或者开关旁边的拨码开关，下载工具会自动开始下载<br><img src="http://oldask.openluat.com/file/attachments-2018-09-PfYPshpL5b9b6076c12ef_QQ%E6%88%AA%E5%9B%BE20180914151701.png" alt="alt"><br><img src="http://oldask.openluat.com/file/attachments-2018-09-sU0R39PO5b9b659ae2c3c_QQ%E6%88%AA%E5%9B%BE20180914153837.png" alt="alt"><br>烧录完成后，关闭烧录对话框，检查一下左上角是否勾上了自动usb口，如果已勾选，等待十几秒后即可看到luatools会输出adc demo的trace：<br><img src="http://oldask.openluat.com/file/attachments-2018-09-Rd74yE8b5b9b660ac91a6_QQ%E6%88%AA%E5%9B%BE20180914154050.png" alt="alt"></p>
<h1 id="第二期-控制LED小灯"><a href="#第二期-控制LED小灯" class="headerlink" title="第二期 控制LED小灯"></a>第二期 控制LED小灯</h1><p>本教程使用的开发板为S9开发板，使用其他开发板的请使用杜邦线连接相关的引脚，代码也请根据需要自行修改 </p>
<p>接触过单片机的人应该都知道，使用一款单片机，第一件事就是学会如何点亮LED灯，学会了控制LED灯，就相当于学会了最基础的GPIO高低电平控制操作</p>
<h2 id="准备一个代码编辑器"><a href="#准备一个代码编辑器" class="headerlink" title="准备一个代码编辑器"></a>准备一个代码编辑器</h2><p>代码编辑器有很多可供选择，比如notepad++、Sublime Text</p>
<pre><code>如果你已经可以熟练掌握了某一个代码编辑器，那么你可以直接跳过这一章，直接看代码编写。如果你想试试我推荐的编辑器，那么也可以看下去
</code></pre>
<h4 id="详细的安装和配置，请参考这篇文章vscode-lua开发推荐配置"><a href="#详细的安装和配置，请参考这篇文章vscode-lua开发推荐配置" class="headerlink" title="详细的安装和配置，请参考这篇文章vscode lua开发推荐配置"></a>详细的安装和配置，请参考这篇文章vscode lua开发推荐配置</h4><h2 id="新建一个最基本的工程"><a href="#新建一个最基本的工程" class="headerlink" title="新建一个最基本的工程"></a>新建一个最基本的工程</h2><p>在你觉得适当的位置，新建一个文件夹，名为LUAT-LED，使用你的代码编辑器打开该文件夹，vscode如下图所示操作：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-j0k4s1nt5b800abd3c5ba.png" alt="alt"><br>打开后，在编辑器左侧的文件夹中，右击空白处，新建文件，输入文件名main.lua，回车键保存：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-SRWSpjPq5b800ad3d0255.png" alt="alt"><br>接着，在新建的文件夹中添加如下代码，完成最主要的main.lua文件的编写：</p>
<pre><code>--必须在这个位置定义PROJECT和VERSION变量
--PROJECT：ascii string类型，可以随便定义，只要不使用,就行
--VERSION：ascii string类型，如果使用Luat物联云平台固件升级的功能，必须按照&quot;X.X.X&quot;定义，X表示1位数字；否则可随便定义
PROJECT = &quot;LED-TEST&quot;
VERSION = &quot;0.0.1&quot;
--根据固件判断模块类型
moduleType = string.find(rtos.get_version(),&quot;8955&quot;) and 2 or 4
--加载日志功能模块，并且设置日志输出等级
--如果关闭调用log模块接口输出的日志，等级设置为log.LOG_SILENT即可
require &quot;log&quot;
LOG_LEVEL = log.LOGLEVEL_TRACE
require &quot;sys&quot;
require &quot;net&quot;
--每1分钟查询一次GSM信号强度
--每1分钟查询一次基站信息
net.startQueryAll(60000, 60000)
--加载硬件看门狗功能模块
--根据自己的硬件配置决定：1、是否加载此功能模块；2、配置Luat模块复位单片机引脚和互相喂狗引脚
--合宙官方出售的Air201开发板上有硬件看门狗，所以使用官方Air201开发板时，必须加载此功能模块
--如果用的是720 4g模块，请注释掉这两行
require &quot;wdt&quot;
wdt.setup(pio.P0_30, pio.P0_31)
--加载网络指示灯功能模块
--根据自己的项目需求和硬件配置决定：1、是否加载此功能模块；2、配置指示灯引脚
--合宙官方出售的Air800和Air801开发板上的指示灯引脚为pio.P0_28，其他开发板上的指示灯引脚为pio.P1_1
require &quot;netLed&quot;
netLed.setup(true,moduleType == 2 and pio.P1_1 or pio.P2_0,moduleType == 2 and nil or pio.P2_1)--自动判断2/4g默认网络灯引脚配置
--网络指示灯功能模块中，默认配置了各种工作状态下指示灯的闪烁规律，参考netLed.lua中ledBlinkTime配置的默认值
--如果默认值满足不了需求，此处调用netLed.updateBlinkTime去配置闪烁时长
--加载错误日志管理功能模块【强烈建议打开此功能】
--如下2行代码，只是简单的演示如何使用errDump功能，详情参考errDump的api
require &quot;errDump&quot;
errDump.request(&quot;udp://ota.airm2m.com:9072&quot;)
--加载远程升级功能模块【强烈建议打开此功能】
--如下3行代码，只是简单的演示如何使用update功能，详情参考update的api以及demo/update
-- PRODUCT_KEY = &quot;xxxxxx&quot;
-- require &quot;update&quot;
-- update.request()
--启动系统框架
sys.init(0, 0)
sys.run()
</code></pre>
<p>我们将main.lua和基本的task库文件烧录到开发板中（不烧录会的请看第一章），会发现：并没有什么事情发生<br>因为代码基本是空的啊2333<br>##模块化编程</p>
<p>在编写lua功能时，我们一般会把相似功能的代码放到同一个文件中，写完后只需要在main.lua中添加require语句即可，所以我们需要将main.lua结尾改成如下形式：</p>
<pre><code>....上面一堆代码省略
--加载远程升级功能模块【强烈建议打开此功能】
--如下3行代码，只是简单的演示如何使用update功能，详情参考update的api以及demo/update
-- PRODUCT_KEY = &quot;xxxxxx&quot;
-- require &quot;update&quot;
-- update.request()
require &quot;ledtest&quot;    --新加上的代码
--启动系统框架
sys.init(0, 0)
sys.run()
</code></pre>
<p>添加完后，使用和新建main.lua文件相同的方式，新建一个新的文件ledtest.lua</p>
<p>我们在ledtest.lua的第一行可以先加上如下一句话：</p>
<pre><code>module(..., package.seeall)  --使得文件中的函数在何处都可调用
</code></pre>
<h2 id="连接硬件"><a href="#连接硬件" class="headerlink" title="连接硬件"></a>连接硬件</h2><pre><code>注意：这里演示用的是2g模块，4g模块请详细阅读下面代码注释中的信息进行修改，代码不可以直接拿去用！！
</code></pre>
<p>由于我这里使用的是普通的S9开发板，和一个配套的LED灯小主板，所以我直接将其连接到了双排针上，插入方式如下图：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-dFQTv3VK5b800af7e5562.png" alt="alt"><br>为了照顾其他未使用S9开发板的读者，我将led的电气连接在下方进行标识，有条件的可以手动按下文进行连接（用的是Air202模块，其他模块请根据情况自行修改）：<br>引脚名称     灯序号     另一端连接哪里<br>SPI1_CLK/GPIO_8     LED1     GND<br>SPI1_DO/GPIO_11     LED2     GND<br>SPI1_DI/GPIO_12     LED3     GND<br>UART1_CTS/GPIO_3     LED4     GND<br>UART1_RTS/GPIO_2     LED5     GND</p>
<p>可以看到，每个管脚都有各种复用功能，我们本文之将其作为普通GPIO口使用</p>
<h2 id="点亮LED小灯"><a href="#点亮LED小灯" class="headerlink" title="点亮LED小灯"></a>点亮LED小灯</h2><p>模块中几乎所有的函数都可以在wiki中找到，所以我们也去wiki中进行搜索<br>打开openluat的wiki页：<a target="_blank" rel="noopener" href="http://wiki.openluat.com/">http://wiki.openluat.com/</a><br>在网页左边选择Luat API接口，可以看到所有接口都被整理好放到了这里，点击LuaTask—pins可以找到我们需要的函数接口：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-lhU9G8GF5b800b1502db4.png" alt="alt"><br>这样我们就明白这个改如何点亮LED小灯了，我们将ledtest.lua改成如下代码：</p>
<pre><code>module(..., package.seeall)
require&quot;pins&quot;  --用到了pin库，该库为luatask专用库，需要进行引用
-- GPIO 0到GPIO 31表示为pio.P0_0到pio.P0_31 。 
-- GPIO 32到GPIO XX表示为pio.P1_0到pio.P1_(XX-32)，例如GPIO33 表示为pio.P1_1
if moduleType == 2 then
    pmd.ldoset(5,pmd.LDO_VMMC)  --使用某些GPIO时，必须在脚本中写代码打开GPIO所属的电压域，配置电压输出输入等级，这些GPIO才能正常工作
end
--注意！！！4G模块无需设置电压域！
--设置led的GPIO口
local led1 = pins.setup(pio.P0_8,0)--如果你用的是4G模块，请更改这个gpio编号
local led2 = pins.setup(pio.P0_11,0)--如果你用的是4G模块，请更改这个gpio编号
local led3 = pins.setup(pio.P0_12,0)--如果你用的是4G模块，请更改这个gpio编号
local led4 = pins.setup(pio.P0_3,0)--如果你用的是4G模块，请更改这个gpio编号
local led5 = pins.setup(pio.P0_2,0)--如果你用的是4G模块，请更改这个gpio编号
--将gpio口都置为高电平
led1(1)
led2(1)
led3(1)
led4(1)
led5(1)
</code></pre>
<p>更改完保存后，将改好的文件全部烧入模块中，查看效果<br>如果一切正常的话，五个灯都会正常被点亮<br>将led1(1)改为led1(0)即可熄灭第一个灯，以此类推，可以多尝试更改着玩一下，再看下一部分<br>让LED灯闪烁起来</p>
<p>LED灯已经可以点亮了，那么我们就要让它动起来<br>我们可以在wiki页查到，开启一个定时器函数为sys.timerStart(fnc, ms, …)，那么我们可以将代码改成如下样式：</p>
<pre><code>module(..., package.seeall)
require&quot;pins&quot;  --用到了pin库，该库为luatask专用库，需要进行引用
-- GPIO 0到GPIO 31表示为pio.P0_0到pio.P0_31 。 
-- GPIO 32到GPIO XX表示为pio.P1_0到pio.P1_(XX-32)，例如GPIO33 表示为pio.P1_1
if moduleType == 2 then
    pmd.ldoset(5,pmd.LDO_VMMC)  --使用某些GPIO时，必须在脚本中写代码打开GPIO所属的电压域，配置电压输出输入等级，这些GPIO才能正常工作
end
--注意！！！4G模块无需设置电压域！
--设置led的GPIO口
local led1 = pins.setup(pio.P0_8,0)--如果你用的是4G模块，请更改这个gpio编号
local led2 = pins.setup(pio.P0_11,0)--如果你用的是4G模块，请更改这个gpio编号
local led3 = pins.setup(pio.P0_12,0)--如果你用的是4G模块，请更改这个gpio编号
local led4 = pins.setup(pio.P0_3,0)--如果你用的是4G模块，请更改这个gpio编号
local led5 = pins.setup(pio.P0_2,0)--如果你用的是4G模块，请更改这个gpio编号
local ledon = false --led是否开启
function changeLED()
    if ledon then
        led1(1)
        led2(1)
        led3(1)
        led4(1)
        led5(1)
    else
        led1(0)
        led2(0)
        led3(0)
        led4(0)
        led5(0)
    end
    ledon = not ledon
    sys.timerStart(changeLED,1000)--一秒后执行指定函数
end
changeLED() --开机后立刻运行该函数
</code></pre>
<p>保存后烧入程序即可，如果不出意外，五个LED灯就应该一秒亮一秒灭了</p>
<p>既然学会了延时、点亮LED、熄灭LED，那么就可以自己尝试编写一个流水灯了，这里不再赘述，请大家自己尝试</p>
<h1 id="第三期-LUAT程序的基本时序"><a href="#第三期-LUAT程序的基本时序" class="headerlink" title="第三期 LUAT程序的基本时序"></a>第三期 LUAT程序的基本时序</h1><p>本文只会介绍LuaTask中多线程任务的基本用法，不会过多的讨论原理，如果需要深入研究，请查看wiki页的详细介绍：<a target="_blank" rel="noopener" href="http://wiki.openluat.com/">http://wiki.openluat.com</a></p>
<pre><code>适合阅读本文的人
至少用过一款单片机的
接触、了解过或听说过rtos、ucos等多线程系统
前几篇文章所提内容都已经懂了的
有耐心看完本文的
对lua语法熟悉的，如不熟悉请移步
http://www.runoob.com/lua/lua-tutorial.html
或
https://www.lua.org/manual/5.1/manual.html
进行学习。 
</code></pre>
<p>本文只会介绍LuaTask中多线程任务的基本用法，不会过多的讨论原理，如果需要深入研究，请查看wiki页的详细介绍：<a target="_blank" rel="noopener" href="http://wiki.openluat.com/doc/run/">http://wiki.openluat.com/doc/run/</a></p>
<h2 id="简单定时器函数的使用"><a href="#简单定时器函数的使用" class="headerlink" title="简单定时器函数的使用"></a>简单定时器函数的使用</h2><p>上一章里的点亮led小灯，最后一步是让led灯闪烁起来。习惯了c语言写代码的人可能会发现，这个lua程序中好像没有delay之类的函数。</p>
<p>我们把上一章的代码简化一下，像如下这样：</p>
<pre><code>function sayHello()
print(&quot;hello&quot;)
sys.timerStart(sayHello,1000)--一秒后执行指定函数
print(&quot;bye&quot;)
end

sayHello()

.....其他代码
</code></pre>
<p>这里使用了定时器的接口：sys.timerStart(fnc, ms, …)，用过js之类语言的可能会感到特别熟悉。在luat中，一般不在主线程中使用类似c一样用死循环阻塞式地来延时，取而代之的是这种定时器的结构，流程图如下：</p>
<p><img src="http://oldask.openluat.com/image/show/attachments-2018-08-2RFA4bxN5b80c9f706619.png" alt="alt"></p>
<p>其实实现上述定时器循环执行某函数的功能，可以直接使用sys.timerLoopStart(fnc, ms, …)接口，改成如下样式：</p>
<p>function sayHello()<br>    print(“hello”)<br>end</p>
<p>sys.timerLoopStart(sayHello,1000)</p>
<p>…..其他代码</p>
<p>Lua<br>Copy</p>
<p>整个流程图便变成了如下的顺序：</p>
<p><img src="http://oldask.openluat.com/image/show/attachments-2018-08-Lxds7UjR5b80ca16eadd6.png" alt="alt"></p>
<p>为了使函数更简洁，我们可以直接把函数名改成function() ….. end的形式，在函数变量中直接定义要使用的函数：</p>
<p>sys.timerLoopStart(function()<br>                       print(“hello”)<br>                   end,1000)</p>
<p>Lua<br>Copy</p>
<p>甚至可以写成一行：</p>
<p>sys.timerLoopStart(function() print(“hello”) end,1000)</p>
<p>Lua<br>Copy</p>
<p>上述两段代码的功能与一开始的timerLoopStart示例代码的运行结果完全相同</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>在wiki页中，给出了这样一段简洁的代码，我们为了照顾不熟悉lua语言的人，稍微改一下代码：</p>
<p>test.lua</p>
<pre><code>function test()
    while true do
        print(&quot;ss function test&quot;)
        sys.wait(1000)          -- 挂起1000ms，同理为每隔1000ms运行一次
    end
end

sys.taskInit(test)

.....其他代码
</code></pre>
<p>在这里，sys.taskInit的作用可以理解为创建了一个新的线程，这个线程运行的内容就是test()函数</p>
<p>在test()进行while true这样的死循环时，并不会使其他程序被阻塞运行，反而是多线程运行的</p>
<p>在LuaTask架构下，协程内的函数可以直接使用sys.wait(ms)函数进行延时操作，延时途中只是将cpu让给了其他需要运行的程序，在倒计时完成后继续该进程的运行，从而实现了延时操作</p>
<p>我们一般会把sys.taskInit内的函数直接写在其中，像下面这样：</p>
<pre><code>sys.taskInit(function()
    while true do
        print(&quot;ss function test&quot;)
        sys.wait(1000)          -- 挂起1000ms，同理为每隔1000ms运行一次
    end
end)

.....其他代码
</code></pre>
<p>相信各位已经可以理解这种写法了（如果从文章开头看到这里了的话），协程的运行流程图如下</p>
<p><img src="http://oldask.openluat.com/image/show/attachments-2018-08-VchwfAC35b80ca5330f35.png" alt="alt"></p>
<p>我们可以同时开多个线程，使用方法都是一样的</p>
<h2 id="程序注册"><a href="#程序注册" class="headerlink" title="程序注册"></a>程序注册</h2><p>LuaTask可以使用订阅和发布，使某个程序等待另一个程序完成后才继续运行</p>
<p>我们来看最简单的一个示例代码：</p>
<p><img src="http://oldask.openluat.com/image/show/attachments-2018-08-rxZWfyuj5b80cc9fbd240.png" alt="alt"></p>
<p>程序定义了一个5秒后的定时器，并运行了一个包含了时间订阅等待的函数，整体流程运行如下：</p>
<p><img src="http://oldask.openluat.com/image/show/attachments-2018-08-v0MVTubI5b80ca9a053cb.png" alt="alt"></p>
<p>这种用法经常用在http、socket等操作和其他需要等待的操作中，利用回调函数可实现等待功能。</p>
<p>sys.publish也可传递参数：</p>
<p>sys.timerStart(function()<br>                   sys.publish(“TEST”,123)<br>               end,3000)–三秒后执行发布”TEST”消息的函数</p>
<p>function sub()<br>    print(“start”)<br>    result,data = sys.waitUntil(“TEST”)<br>    print(result,data)<br>end</p>
<p>sys.taskInit(sub)</p>
<p>Lua<br>Copy</p>
<p>上述代码将会输出：</p>
<p>true    123</p>
<p>同时，luat在库中自带了许多系统消息，部分如下：</p>
<p><img src="http://oldask.openluat.com/image/show/attachments-2018-08-kHOv44o75b80caf440093.png" alt="alt"></p>
<p>三种线程控制的使用方法全部介绍完毕了，如果需要了解原理，请去研读<a target="_blank" rel="noopener" href="http://wiki.openluat.com/">http://wiki.openluat.com</a> 的说明与解释</p>
<h1 id="第四期-学会使用并看懂luatools的trace信息"><a href="#第四期-学会使用并看懂luatools的trace信息" class="headerlink" title="第四期 学会使用并看懂luatools的trace信息"></a>第四期 学会使用并看懂luatools的trace信息</h1><p>由于luat这个架构并不能直接连接仿真器进行调试，所以也无法在程序中设置断点来检查自己代码是否有问题，所以在开发过程中，一般我们都是靠各种print来输出trace获取程序运行的各种状态的。 并且由于lua是脚本文件，烧录时并没有进行编译，所以就算是报错，报错信息也可以准确地把错误所在行的具体位置详细指出来，方便我们进行排查问题</p>
<pre><code>适合阅读本文的人需要：
理解或已经学习了前几章的内容
熟悉lua语法
有实际模块，可以自己实践验证
能耐心阅读完本文
有问题会在文章下方进行留言
</code></pre>
<p>由于luat这个架构并不能直接连接仿真器进行调试，所以也无法在程序中设置断点来检查自己代码是否有问题，所以在开发过程中，一般我们都是靠各种print来输出trace获取程序运行的各种状态的。<br>并且由于lua是脚本文件，烧录时并没有进行编译，所以就算是报错，报错信息也可以准确地把错误所在行的具体位置详细指出来，方便我们进行排查问题</p>
<h2 id="trace的几个基本部分"><a href="#trace的几个基本部分" class="headerlink" title="trace的几个基本部分"></a>trace的几个基本部分</h2><p>首先我们随便烧录一个程序，就只包含下面一个main.lua和自带的LuaTask库文件好了：<br>main.lua</p>
<pre><code>PROJECT = &quot;LOG-TEST&quot;
VERSION = &quot;1.0.0&quot;
--加载日志功能模块，并且设置日志输出等级
--如果关闭调用log模块接口输出的日志，等级设置为log.LOG_SILENT即可
require &quot;log&quot;
LOG_LEVEL = log.LOGLEVEL_TRACE
require &quot;sys&quot;
require &quot;net&quot;
--每1分钟查询一次GSM信号强度
--每1分钟查询一次基站信息
net.startQueryAll(60000, 60000)
--加载硬件看门狗功能模块
--根据自己的硬件配置决定：1、是否加载此功能模块；2、配置Luat模块复位单片机引脚和互相喂狗引脚
--合宙官方出售的Air201开发板上有硬件看门狗，所以使用官方Air201开发板时，必须加载此功能模块
require &quot;wdt&quot;
wdt.setup(pio.P0_30, pio.P0_31)
--加载网络指示灯功能模块
--根据自己的项目需求和硬件配置决定：1、是否加载此功能模块；2、配置指示灯引脚
--合宙官方出售的Air800和Air801开发板上的指示灯引脚为pio.P0_28，其他开发板上的指示灯引脚为pio.P1_1
require &quot;netLed&quot;
netLed.setup(true,pio.P1_1)
--加载错误日志管理功能模块【强烈建议打开此功能】
--如下2行代码，只是简单的演示如何使用errDump功能，详情参考errDump的api
require &quot;errDump&quot;
errDump.request(&quot;udp://ota.airm2m.com:9072&quot;)
--启动系统框架
sys.init(0, 0)
sys.run()
</code></pre>
<p>程序中除了必要的声明软件版本和名称、初始化看门狗、初始化网络灯、加载错误日志管理功能模块、启动系统框架之外，没有进行其他任何操作（lib库文件和lod底层里进行的各种操作除外）<br>我们可以将这个文件烧录到开发板中，查看trace的各种信息（这里用的是S9开发板）：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-zqejrkLg5b80ccf881f86.png" alt="alt"><br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-MRIMreS55b80cd1353c4c.png" alt="alt"></p>
<p>↑显示烧录成功后，最好立即关闭烧录界面，以免错过一些开头的trace信息。实际开发中一般错过了也没事，反正开头的一些东西也没什么用</p>
<p>我们可以看到trace中输出了一些信息：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-bwJsOQOb5b80cd25ac9f6.png" alt="alt"><br>    由于trace中大多数的信息是由lib库文件打印出来的，随时可能会有更改，所以下面也就讲个大概，具体要以实际为准</p>
<p>为了更好地观察，我们可以点击停止打印按钮，以免刷新新的log信息导致滚动条回到最低端：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-5Qp0X2s15b80cd3f7b0fe.png" alt="alt"><br>    [时间]: CDFU_LoadSection: %d-%d<br>    [时间]: CDFU_LoadSection: %d-%d<br>    [时间]: ====================================<br>    [时间]: INTR VER :Luat_V0027_8955_SSL_UI<br>    [时间]: BASE VER :B5431<br>    [时间]: SCRIPT ADDR :0x002b0000<br>    [时间]: SCRIPT SIZE :0x000b0000<br>    [时间]: BASE   ADDR :0x00220000<br>    [时间]: BASE   SIZE :0x00090000<br>    [时间]: ====================================<br>    [时间]: [cust_task_main]: Enter message loop<br>    [时间]: INTEGRITY file not exist!<br>    [时间]: FH:file=/lua/wdt.lua,len=589,offset=29006<br>    [时间]: FH:file=/lua/utils.lua,len=2526,offset=26455<br>    [时间]: FH:file=/lua/sys.lua,len=5472,offset=20956<br>    [时间]: FH:file=/lua/sim.lua,len=1084,offset=19847<br>    [时间]: FH:file=/lua/ril.lua,len=7790,offset=12032<br>    [时间]: FH:file=/lua/pins.lua,len=946,offset=11061<br>    [时间]: FH:file=/lua/patch.lua,len=1186,offset=9849<br>    [时间]: FH:file=/lua/netLed.lua,len=2601,offset=7221<br>    [时间]: FH:file=/lua/net.lua,len=5141,offset=2052<br>    [时间]: FH:file=/lua/main.lua,len=280,offset=1747<br>    [时间]: FH:file=/lua/log.lua,len=1174,offset=547<br>    [时间]: FH:file=/lua/clib.lua,len=472,offset=50<br>    [时间]: parse_luadb_data:delupdpack=0,err=0,section=1,wrFile=0<br>    [时间]: INTEGRITY file write begin!<br>    [时间]: lualibc_fopen /integrity.bin wb 601 1 2<br>    [时间]: INTEGRITY file write success!<br>    [时间]: [fopen_ext]: /lua/main.lua 2!<br>    [时间]: RUN main.lua<br>    [时间]: [fopen_ext]: /lua/main.lua 2!<br>    [时间]: [fopen_ext]: /lua/log.lua 2!<br>    [时间]: [fopen_ext]: /lua/log.lua 2!<br>    [时间]: [fopen_ext]: /lua/sys.lua 2!<br>    [时间]: [fopen_ext]: /lua/sys.lua 2!<br>    [时间]: [fopen_ext]: /lua/utils.lua 2!<br>    [时间]: [fopen_ext]: /lua/utils.lua 2!<br>    [时间]: [fopen_ext]: /lua/patch.lua 2!<br>    [时间]: [fopen_ext]: /lua/patch.lua 2!<br>    [时间]: [fopen_ext]: /lua/clib.lua 2!<br>    [时间]: [fopen_ext]: /lua/clib.lua 2!<br>    [时间]: [fopen_ext]: /lua/net.lua 2!<br>    [时间]: [fopen_ext]: /lua/net.lua 2!<br>    [时间]: [fopen_ext]: /lua/ril.lua 2!<br>    [时间]: [fopen_ext]: /lua/ril.lua 2!<br>    [时间]: [fopen_ext]: /lua/sim.lua 2!<br>    [时间]: [fopen_ext]: /lua/sim.lua 2!<br>    [时间]: [fopen_ext]: /lua/wdt.lua 2!<br>    [时间]: [fopen_ext]: /lua/wdt.lua 2!<br>    [时间]: [fopen_ext]: /lua/pins.lua 2!<br>    [时间]: [fopen_ext]: /lua/pins.lua 2!<br>    [时间]: [I]-[wdt.taskWdt]    AirM2M –&gt; WATCHDOG : OK<br>    [时间]: [fopen_ext]: /lua/netLed.lua 2!<br>    [时间]: [fopen_ext]: /lua/netLed.lua 2!<br>    /<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong>温馨提示**<strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong>/<br>    软件开机,如果是意外重启,请去<a target="_blank" rel="noopener" href="http://wiki.openluat.com/doc/luatApi/#rtospoweron,%E6%9F%A5%E7%9C%8B">http://wiki.openluat.com/doc/luatApi/#rtospoweron,查看</a><br>    /<strong><strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></strong>提示结束**<strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong>/</p>
<p>开头的这一些代码表示读取到了上述的这些文件，可以用于后续的运行</p>
<pre><code>注意：
我们烧录进模块的lua文件一般都在/lua/路径下
而烧录的其他文件如png图片、mp3音乐，则会在/ldata/路径下

[时间]: [I]-[poweron reason:]    3    LOG-TEST    1.0.0    2.0.8    Luat_V0027_8955_SSL_UI
</code></pre>
<p>这一行代表了上次关机的原因、脚本工程里定义的名称（main.lua第1行写的）、脚本工程里定义的版本号（main.lua第2行写的）、LuaTask库文件的版本号（1.x.x是旧版的lua script，2.x.x是LuaTask）、lod固件的版本号</p>
<pre><code>[时间]: LJD VSIM sim_SetNextVoltage:1048,sim_present=0,IsVsim=0
[时间]: LJD VSIM sim_ProcessInstruction:2784,sim_present=1,IsVsim=1
</code></pre>
<p>这两行的IsVsim=1代表了当前模块拥有虚拟sim卡，sim_present=1代表没检测到外置sim卡，所以就使用内置的虚拟sim卡（可能是吧，我猜的）</p>
<pre><code>[时间]: [I]-[ril.defrsp]    AT+CMEE=0    true    OK    nil
[时间]: [I]-[ril.sendat]    AT+CREG=2
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.defrsp]    AT+CREG=2    true    OK    nil
[时间]: [I]-[ril.sendat]    AT+CREG?
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +CREG: 2,0
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.defrsp]    AT+CREG?    true    OK    nil
[时间]: [I]-[ril.sendat]    AT+CENG=1,1
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.sendat]    AT+CSQ
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +CSQ: 0,0
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.sendat]    AT+CENG?
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +CENG:1,1
[时间]: [I]-[ril.proatc]    +CENG:0,&quot;0000, 0, 0,000,00,00,0000,00,00,0000,00&quot;
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.sendat]    AT+CSQ
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +CSQ: 0,0
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.sendat]    AT+CENG?
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +CENG:1,1
[时间]: [I]-[ril.proatc]    +CENG:0,&quot;0000, 0, 0,000,00,00,0000,00,00,0000,00&quot;
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +CSIMTYPE: 0,0
[时间]: [I]-[ril.defurc]    +CSIMTYPE: 0,0
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +ENCRET: 0
[时间]: [I]-[ril.defurc]    +ENCRET: 0
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    +CPIN: READY
</code></pre>
<p>上面这些就是lua脚本底层里，调用AT接口来对模块进行的操作了。熟悉AT指令的人会一下子就明白这些，不熟悉的人可以无视，只要知道这些是调用的AT指令就可以，操作基本都由底层和lib库来完成，一般情况下不用接触</p>
<pre><code>[时间]: [I]-[wdt.taskWdt]    AirM2M --&gt; WATCHDOG : OK
[时间]: [I]-[wdt.taskWdt]    AirM2M &lt;-- WatchDog : OK
</code></pre>
<p>这是看门狗的喂狗操作。。。我觉得我不用解释了吧。。。</p>
<pre><code>[时间]: [I]-[ril.defrsp]    AT+CIPSTATUS    true    OK    nil
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    STATE: IP INITIAL
[时间]: [I]-[link.STATE]    IP STATUS    IP INITIAL
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    C: 0,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 0,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 1,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 1,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 2,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 2,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 3,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 3,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 4,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 4,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 5,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 5,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 6,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 6,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 7,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 7,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.sendat]    AT+CSTT=&quot;CMIOT&quot;,&quot;&quot;,&quot;&quot;
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.defrsp]    AT+CSTT=&quot;CMIOT&quot;,&quot;&quot;,&quot;&quot;    true    OK    nil
[时间]: [I]-[ril.sendat]    AT+CIICR
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.defrsp]    AT+CIICR    true    OK    nil
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    STATE: IP GPRSACT
[时间]: [I]-[link.STATE]    IP STATUS    IP GPRSACT
[时间]: [I]-[ril.sendat]    AT+CIFSR
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    010.007.081.239
[时间]: [I]-[ril.defrsp]    AT+CIFSR    true    nil    010.007.081.239
[时间]: [I]-[ril.sendat]    AT+CIPSTATUS
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    OK
[时间]: [I]-[ril.defrsp]    AT+CIPSTATUS    true    OK    nil
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    STATE: IP STATUS
[时间]: [I]-[link.STATE]    IP STATUS    IP STATUS
[时间]: [I]-[ril.proatc]    
[时间]: [I]-[ril.proatc]    C: 0,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 0,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 1,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 1,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 2,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 2,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 3,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 3,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 4,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 4,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 5,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 5,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 6,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 6,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.proatc]    C: 7,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
[时间]: [I]-[ril.defurc]    C: 7,,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;INITIAL&quot;
</code></pre>
<p>熟悉AT的各位如果看到这两大串，一定又明白了，这模块连上GPRS网络了。不明白的大概了解一下就好，可以在测试时作为参考</p>
<p>基本的trace就讲到这里，具体的自己去研究吧</p>
<h2 id="自定义输出trace（LuaTask格式）"><a href="#自定义输出trace（LuaTask格式）" class="headerlink" title="自定义输出trace（LuaTask格式）"></a>自定义输出trace（LuaTask格式）</h2><p>在第一版lua script时代，输出的trace基本都是直接使用print(xxxxx)这种格式，这个输出习惯的效果不怎么样，也不利于排查问题<br>于是在稀饭放姜大佬写的LuaTask版本中，使用了log语句，输出整齐具有区分度较高格式的trace</p>
<p>老套路，我们在上面的main.lua中稍作修改，在–启动系统框架的上方添加如下代码：</p>
<pre><code>require&quot;logtest&quot;
</code></pre>
<p>并且新建一个lua文件，名为logtest.lua，文件内容如下：</p>
<pre><code>require&quot;common&quot;
local function test()
    log.info(&quot;logtest.test&quot;,common.utf8ToGb2312(&quot;输出info级别的日志&quot;))
    log.debug(&quot;logtest.test&quot;,common.utf8ToGb2312(&quot;输出debug级别的日志&quot;))
    log.trace(&quot;logtest.test&quot;,common.utf8ToGb2312(&quot;输出trace级别的日志&quot;))
    log.warn(&quot;logtest.test&quot;,common.utf8ToGb2312(&quot;输出warn级别的日志&quot;))
    log.error(&quot;logtest.test&quot;,common.utf8ToGb2312(&quot;输出error级别的日志&quot;))
    log.fatal(&quot;logtest.test&quot;,common.utf8ToGb2312(&quot;输出fatal级别的日志&quot;))
end
test()

注意：
由于vscode新建文件默认都为utf8编码格式，
所以我们在代码中输出的中文字符也都为utf8编码格式。但是luatools使用的却是GB2312格式，所以为了输出正确不乱码的中文，我们需要对中文进行转码，使用common.utf8ToGb2312()函数就可以解决这个编码问题
输出英文没有类似问题，无需转码
</code></pre>
<p>我们把logtest.lua文件添加到烧录工程中，将程序烧录进去，可以得到如下的输出结果（需要自己在luatools往上翻地找）：</p>
<p>同时，log输出也可以改成如下语句：</p>
<p>testlog.lua</p>
<pre><code>local function test()
    local a = 1
    local b = true
    local c = &quot;test&quot;
    log.info(&quot;logtest.test&quot;,&quot;mixed output&quot;,a,b,c)
end
test()
</code></pre>
<p>输出如下：</p>
<pre><code>[时间]: [I]-[logtest.test]    mixed output    1    true    test
</code></pre>
<p>这些输出日志方便了我们调试的过程，我们可以在程序必要处添加这些log输出，以便通过trace掌握程序运行的状态<br>##语法错误输出</p>
<p>为了演示，我们可以再次更改testlog.lua文件的内容如下：</p>
<p>testlog.lua</p>
<pre><code>local function test()
    local a
    local b = 10
    b = a + b
end
test()
</code></pre>
<p>显而易见，这是会产生语法错误的，没看懂的也不要紧，烧录到模块中，可以看一下trace输出了什么：</p>
<pre><code>[时间]: [E]-[errDump.luaErr]    /lua/logtest.lua:4: attempt to perform arithmetic on local &#39;a&#39; (a nil value)
程序运行错误，请根据上方提示,找到对应lua文件修改程序
[时间]: stack traceback:
[时间]:     /lua/logtest.lua:4: in function &#39;test&#39;
[时间]:     /lua/logtest.lua:7: in main chunk
[时间]:     [C]: in function &#39;require&#39;
[时间]:     /lua/main.lua:34: in main chunk
[时间]:     [C]: ?
[时间]: [fopen_ext]: /lua/logtest.lua 2!
[时间]: [fopen_ext]: /lua/logtest.lua 2!
[时间]: lualibc_fopen /luaerrinfo.txt w 601 1 2
[时间]: lua: /lua/logtest.lua:4: attempt to perform arithmetic on local &#39;a&#39; (a nil value)
程序运行错误，请根据上方提示,找到对应lua文件修改程序
[时间]: stack traceback:
[时间]:     /lua/logtest.lua:4: in function &#39;test&#39;
[时间]:     /lua/logtest.lua:7: in main chunk
[时间]:     [C]: in function &#39;require&#39;
[时间]:     /lua/main.lua:34: in main chunk
[时间]:     [C]: ?
[时间]: [lua_shell_main]: lua exit status 1
</code></pre>
<p>第一行的/lua/logtest.lua:4: attempt to perform arithmetic on local ‘a’ (a nil value)代表了这个错误的具体原因，我们可以直接到错误的行数寻找，同时错误信息也写得十分明确：a是个nil值，无法进行算术计算</p>
<p>如果你觉得这个报错十分准确的话，那你就错了，如果真是这样我就不会在下面再加一段解释了</p>
<p>再次修改testlog.lua文件的内容如下：</p>
<p>testlog.lua</p>
<pre><code>require&quot;utils&quot;
local function test()
    local a = &quot;&quot;
    log.info(&quot;logtest.test&quot;,string.toHex(a))
end
test()
</code></pre>
<p>报错信息如下：</p>
<pre><code>[时间]: lua: /lua/utils.lua:19: attempt to index local &#39;str&#39; (a nil value)
程序运行错误，请根据上方提示,找到对应lua文件修改程序
[时间]: stack traceback:
[时间]:     /lua/utils.lua:19: in function &#39;toHex&#39;
[时间]:     /lua/logtest.lua:5: in function &#39;test&#39;
[时间]:     /lua/logtest.lua:8: in main chunk
[时间]:     [C]: in function &#39;require&#39;
[时间]:     /lua/main.lua:34: in main chunk
[时间]:     [C]: ?
[时间]: [lua_shell_main]: lua exit status 1
</code></pre>
<p>可能有人看到这个报错就凌乱了：utils.lua？这文件不是我写的啊？</p>
<p>确实，utils.lua这个文件是lib文件夹中的库文件，库文件中的函数报错也会导致trace中显示这个文件的错误位置<br>我们可以在错误报告中找到/lua/logtest.lua:5 : in function ‘test’这一段，在检查后发现，确实是logtest.lua文件的第五行导致了错误：对nil进行转成16进制字符串的处理是非法的</p>
<p>以上就是luatools中trace解析的基本解释，很多trace信息还需要各位自己来摸索，用的多了也就熟悉了这些信息了</p>
<h1 id="第五期-socket代码详解"><a href="#第五期-socket代码详解" class="headerlink" title="第五期 socket代码详解"></a>第五期 socket代码详解</h1><p>TCP和UDP除了在lua代码声明时有一些不同，其他地方完全一样，所以下面的代码将以TCP长连接的数据收发作为示例，如果需要UDP连接，只需要改声明对象时的三个字母即可。</p>
<pre><code>阅读本文需要具有的技能：
看过该系列前几篇文章或明白前几篇文章内容的
熟悉lua语法，尤其是数组部分
可以明白字符串、字节码之间的区别
可以自己实践操作
对tcp/udp通讯有基本的了解
用过这东西
</code></pre>
<p>各位想看mqtt解释的，请等待下一篇文章，不过也可以顺便看看这一篇嘛，二者都差不多的</p>
<h2 id="Socket-TCP-UDP"><a href="#Socket-TCP-UDP" class="headerlink" title="Socket(TCP/UDP)"></a>Socket(TCP/UDP)</h2><p>TCP和UDP除了在lua代码声明时有一些不同，其他地方完全一样，所以下面的代码将以TCP长连接的数据收发作为示例，如果需要UDP连接，只需要改声明对象时的三个字母即可。</p>
<h3 id="先定义一个假装能用来测试的TCP协议（需求）"><a href="#先定义一个假装能用来测试的TCP协议（需求）" class="headerlink" title="先定义一个假装能用来测试的TCP协议（需求）"></a>先定义一个假装能用来测试的TCP协议（需求）</h3><pre><code>客户端每10秒发送一条字符串heart beat
客户端接收到back开头的数据要回复相同的数据
客户端收到bin要回复二进制数组0x11 0x22 0x33
客户端收到time要回复当前时间的时间戳字符串
</code></pre>
<p>示例时序如下：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-5jS7Adof5b80ced3d77c1.png" alt="alt"></p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="官方demo提供的示例代码"><a href="#官方demo提供的示例代码" class="headerlink" title="官方demo提供的示例代码"></a>官方demo提供的示例代码</h3><p>官方代码可以在github的Luat_2G_RDA_8955/script_LuaTask/demo/socket/longConnection目录或luatools的LuaTools 1.x.x\script\script_LuaTask\demo\socket\longConnection目录找到</p>
<p>如果你能看懂官方例程，那么可以直接去使用，不需要再看本文了</p>
<h3 id="socket连接代码的拆解分析"><a href="#socket连接代码的拆解分析" class="headerlink" title="socket连接代码的拆解分析"></a>socket连接代码的拆解分析</h3><p>这一部分会将官方demo的代码拆开来，只保留基础部分，放到一个文件中来解释</p>
<h4 id="建立文件"><a href="#建立文件" class="headerlink" title="建立文件"></a>建立文件</h4><p>首先先新建两个文件，用于测试这个工程</p>
<p>main.lua</p>
<pre><code>PROJECT = &quot;SOCKET-TEST&quot;
VERSION = &quot;1.0.0&quot;
--根据固件判断模块类型
moduleType = string.find(rtos.get_version(),&quot;8955&quot;) and 2 or 4
require &quot;log&quot;
LOG_LEVEL = log.LOGLEVEL_TRACE
require &quot;sys&quot;
--每1分钟查询一次GSM信号强度,每1分钟查询一次基站信息
require &quot;net&quot;
net.startQueryAll(60000, 60000)
--加载硬件看门狗功能模块
--如果用的是720 4g模块，请注释掉这两行
require &quot;wdt&quot;
wdt.setup(pio.P0_30, pio.P0_31)
--加载网络指示灯功能模块
require &quot;netLed&quot;
netLed.setup(true,moduleType == 2 and pio.P1_1 or pio.P2_0,moduleType == 2 and nil or pio.P2_1)
require&quot;longlink&quot;
--启动系统框架
sys.init(0, 0)
sys.run()
</code></pre>
<p>longlink.lua</p>
<pre><code>module(...,package.seeall)
require&quot;socket&quot;
--下面代码一会儿写
</code></pre>
<h3 id="找一个测试用的服务器"><a href="#找一个测试用的服务器" class="headerlink" title="找一个测试用的服务器"></a>找一个测试用的服务器</h3><p>2G模块socket测试和wifi有着本质的区别：没法使用内网来调试，必须要使用一个公网服务器来调试</p>
<p>为了解决这个问题，luat官方提供了一个tcp测试实验室网站服务：<a target="_blank" rel="noopener" href="http://tcplab.openluat.com/">http://tcplab.openluat.com/</a><br>这个工具有一个坏处，就是三分钟没有客户端连接的话就会被强行关闭服务。我们可以在本地用一个tcp调试工具提前连上，就不会被强制关闭服务了。</p>
<p>为了针对这种情况，我临时写了一个工具：<br><a target="_blank" rel="noopener" href="https://github.com/chenxuuu/tcplab.openluat.com">https://github.com/chenxuuu/tcplab.openluat.com</a><br>编译好的文件可以点我下载</p>
<p>打开后可以直接获取从服务器分配的ip、端口，还能接收客户端数据、主动发送数据：<br><img src="http://oldask.openluat.com/image/show/attachments-2018-08-VemLO8Al5b80cf3171da3.png" alt="alt"><br>记住自己获取到的ip和端口，在下面的代码中会被使用到<br>###建立socket线程</p>
<p>一般来说，socket连接都是异步运行的，何时应该发送数据，何时应该接收数据，这些逻辑应该让socket收发的进程自己进行控制</p>
<p>所以我们在longlink.lua中添加一个新的线程（看不懂的回去看前几篇文章），文件改成如下（注意要自己改东西！）：</p>
<p>longlink.lua</p>
<pre><code>module(...,package.seeall)
require&quot;socket&quot;
--测试用的服务器信息，上一部分获取到的那个
local testip,testport = &quot;&quot;,&quot;&quot;
--启动socket客户端任务
sys.taskInit(
function()
    while true do
    --该区域的代码会永久循环运行（除非出现语法错误）
    end
end)
</code></pre>
<h3 id="进行socket连接"><a href="#进行socket连接" class="headerlink" title="进行socket连接"></a>进行socket连接</h3><p>一般来说，我们会在模块成功获取基站分配的ip后，才会进行网络的连接操作，所以我们需要使用socket.isReady()函数来判断是否连接网络，然后再进行网络操作</p>
<p>在成功获取ip后，我们才能新建一个tcp对象，对其进行联网操作，socket客户端线程代码改为如下：</p>
<pre><code>--启动socket客户端任务
sys.taskInit(
function()
    while true do
        --是否获取到了分配的ip(是否连上网)
        if socket.isReady() then
            --新建一个socket对象，如果是udp只需要把tcp改成udp即可
            local socketClient = socket.tcp()
            --尝试连接指定服务器
            if socketClient:connect(testip,testport) then
                --连接成功
                log.info(&quot;longlink.socketClient&quot;,&quot;connect success&quot;)
            else
                log.info(&quot;longlink.socketClient&quot;,&quot;connect fail&quot;)
                --连接失败
            end
        else
            --没连上网，原地等待一秒，一秒后会循环回去重试
            sys.wait(1000)
        end
    end
end)
</code></pre>
<h3 id="对连接失败的处理"><a href="#对连接失败的处理" class="headerlink" title="对连接失败的处理"></a>对连接失败的处理</h3><p>上述代码只是一个简单的连接服务器的代码，并且连上之后没有进行任何的其他操作</p>
<p>为了增加代码的稳健性，我们可以利用sys.waitUntil()函数，设置五分钟内没有获取到ip就开启飞行模式几秒，再关闭，让模块重新去获取GPRS连接：</p>
<pre><code>--启动socket客户端任务
sys.taskInit(
function()
    while true do
        --是否获取到了分配的ip(是否连上网)
        if socket.isReady() then
            --新建一个socket对象，如果是udp只需要把tcp改成udp即可
            local socketClient = socket.tcp()
            --尝试连接指定服务器
            if socketClient:connect(testip,testport) then
                --连接成功
                log.info(&quot;longlink.socketClient&quot;,&quot;connect success&quot;)
            else
                log.info(&quot;longlink.socketClient&quot;,&quot;connect fail&quot;)
                --连接失败
            end
        else
            --没连上网
            --等待网络环境准备就绪，超时时间是5分钟
            sys.waitUntil(&quot;IP_READY_IND&quot;,300000)
            --等完了还没连上？
            if not socket.isReady() then
                --进入飞行模式，20秒之后，退出飞行模式
                net.switchFly(true)
                sys.wait(20000)
                net.switchFly(false)
            end
        end
    end
end)
</code></pre>
<p>同样，我们也可以给socketClient:connect(testip,testport)的连接加上错误次数的判断，连接错误超过五次，强制断开socket连接,等待五秒后重试：</p>
<pre><code>--启动socket客户端任务
sys.taskInit(
function()
    local retryConnectCnt = 0   --失败次数统计
    while true do
        --是否获取到了分配的ip(是否连上网)
        if socket.isReady() then
            --新建一个socket对象，如果是udp只需要把tcp改成udp即可
            local socketClient = socket.tcp()
            --尝试连接指定服务器
            if socketClient:connect(testip,testport) then
                --连接成功
                log.info(&quot;longlink.socketClient&quot;,&quot;connect success&quot;)
                retryConnectCnt = 0 --失败次数清零
            else
                log.info(&quot;longlink.socketClient&quot;,&quot;connect fail&quot;)
                --连接失败
                retryConnectCnt = retryConnectCnt+1 --失败次数加一
            end
            socketClient:close()    --断开socket连接
            if retryConnectCnt&gt;=5 then  --失败次数大于五次了
                link.shut()         --强制断开TCP/UDP连接
                retryConnectCnt=0   --失败次数清零
            end
            sys.wait(5000)
        else
            retryConnectCnt = 0     --没连上网，失败次数清零
            --没连上网
            --等待网络环境准备就绪，超时时间是5分钟
            sys.waitUntil(&quot;IP_READY_IND&quot;,300000)
            --等完了还没连上？
            if not socket.isReady() then
                --进入飞行模式，20秒之后，退出飞行模式
                net.switchFly(true)
                sys.wait(20000)
                net.switchFly(false)
            end
        end
    end
end)
</code></pre>
<h3 id="添加发送-接收处理函数"><a href="#添加发送-接收处理函数" class="headerlink" title="添加发送/接收处理函数"></a>添加发送/接收处理函数</h3><p>到了这一步，整个的socket线程只剩下循环处理接收和发送的数据这一部分与demo不同了，我们直接把这两句话加到socket线程的代码中吧：</p>
<pre><code>--启动socket客户端任务
sys.taskInit(
function()
    local retryConnectCnt = 0   --失败次数统计
    while true do
        --是否获取到了分配的ip(是否连上网)
        if socket.isReady() then
            --新建一个socket对象，如果是udp只需要把tcp改成udp即可
            local socketClient = socket.tcp()
            --尝试连接指定服务器
            if socketClient:connect(testip,testport) then
                --连接成功
                log.info(&quot;longlink.socketClient&quot;,&quot;connect success&quot;)
                retryConnectCnt = 0 --失败次数清零
                --循环处理接收和发送的数据
                while true do
                    if not inMsgProcess(socketClient) then  --接收消息处理函数
                        log.error(&quot;longlink.inMsgProcess error&quot;)
                        break
                    end
                    if not outMsgprocess(socketClient) then --发送消息处理函数
                        log.error(&quot;longlink.outMsgprocess error&quot;)
                        break
                    end
                end
            else
                log.info(&quot;longlink.socketClient&quot;,&quot;connect fail&quot;)
                --连接失败
                retryConnectCnt = retryConnectCnt+1 --失败次数加一
            end
            socketClient:close()    --断开socket连接
            if retryConnectCnt&gt;=5 then  --失败次数大于五次了
                link.shut()         --强制断开TCP/UDP连接
                retryConnectCnt=0   --失败次数清零
            end
            sys.wait(5000)
        else
            retryConnectCnt = 0     --没连上网，失败次数清零
            --没连上网
            --等待网络环境准备就绪，超时时间是5分钟
            sys.waitUntil(&quot;IP_READY_IND&quot;,300000)
            --等完了还没连上？
            if not socket.isReady() then
                --进入飞行模式，20秒之后，退出飞行模式
                net.switchFly(true)
                sys.wait(20000)
                net.switchFly(false)
            end
        end
    end
end)
</code></pre>
<p>可以看到，在接收和发送函数不返回false的情况下，接收和发送循环会一直进行下去；只有当两个函数之一返回false时，才会触发break导致退出该接收和发送循环</p>
<h3 id="inMsgProcess-socketClient-函数"><a href="#inMsgProcess-socketClient-函数" class="headerlink" title="inMsgProcess(socketClient)函数"></a>inMsgProcess(socketClient)函数</h3><p>这段的代码相对来说比较简单，我们可以直接使用socketClient:recv(毫秒数)来接收我们的tcp消息。<br>我们在合适的地方，新建一个inMsgProcess(socketClient)函数：</p>
<pre><code>function inMsgProcess(socketClient)
    local result,data
    while true do
        result,data = socketClient:recv(2000)
        --接收数据
        if result then  --接收成功
            log.info(&quot;longlink.inMsgProcess&quot;,data)
            --处理data数据，现在还没代码，空着
        else    --接收失败
            break
        end
    end
    --返回结果，处理成功返回true，处理出错返回false
    return result or data==&quot;timeout&quot;
end
</code></pre>
<p>这段代码就是循环获取socket消息，如果没获取到，socketClient:recv(2000)就会返回false,”timeout”；如果获取到了，就会返回true,获取到的数据字符串；如果返回了false,不为”timeout”，则表示数据处理出错，说明socket连接有了什么问题</p>
<p>细心的读者可能看出来了，如果接收函数一直在2秒内有接收到数据，那么这段函数会永远无限循环下去，没办法到达outMsgprocess(socketClient)函数进行发送数据的操作，所以我们先去讲outMsgprocess(socketClient)函数的实现过程，再回来改进inMsgProcess(socketClient)函数</p>
<h3 id="outMsgprocess-socketClient-函数"><a href="#outMsgprocess-socketClient-函数" class="headerlink" title="outMsgprocess(socketClient)函数"></a>outMsgprocess(socketClient)函数</h3><p>由于发送函数在socket线程中是一个循环的小部分，所以我们要建立一个消息发送的队列：有要发送的发数据时，将数据放到这个队列中；等运行到outMsgprocess(socketClient)函数时，将队列中的数据一个一个发出去</p>
<p>首先我们要建一个放这种队列的数组，在合适位置声明一下这个数组：</p>
<pre><code>--数据发送的消息队列
local msgQuene = &#123;&#125;
</code></pre>
<p>接着我们构造一个可以往数组里插入数据的函数，table.insert()可以向数组添加数据，所以我们新建一个insertMsg函数：</p>
<pre><code>local function insertMsg(data)
    table.insert(msgQuene,data)
end
</code></pre>
<p>还记得上面说过的消息接收函数函数会永远无限循环下去的问题吗？我们在合适的地方新建一个判断发送消息队列是否为空的函数：</p>
<pre><code>function waitForSend()
    return #msgQuene &gt; 0
end
</code></pre>
<p>在数组有数据时，这个函数会返回true，我们可以将inMsgProcess(socketClient)接收到数据后的代码添加一行判断发送队列是否有数据的代码，当检测到发送队列有数据时，就立即退出接收函数，转而去进行发送动作，接收函数最终改为了这样：</p>
<pre><code>function inMsgProcess(socketClient)
    local result,data
    while true do
        result,data = socketClient:recv(2000)
        --接收到数据
        if result then  --接收成功
            log.info(&quot;longlink.inMsgProcess&quot;,data)
            --处理data数据，现在还没代码，空着
            --如果msgQuene中有等待发送的数据，则立即退出本循环
            if waitForSend() then return true end
        else    --接收失败
            break
        end
    end
    --返回结果，处理成功返回true，处理出错返回false
    return result or data==&quot;timeout&quot;
end
</code></pre>
<p>最后我们终于可以开始写消息发送函数了，整体的函数就是检查队列是否为空，不为空的话就发一条消息并将其从队列中删除，然后重复这一操作，函数代码如下：</p>
<pre><code>function outMsgprocess(socketClient)
    --队列中有消息
    while #msgQuene&gt;0 do
        --获取消息，并从队列中删除
        local outMsg = table.remove(msgQuene,1)
        --发送这条消息，并获取发送结果
        local result = socketClient:send(outMsg)
        --发送失败的话立刻返回nil（等同于false）
        if not result then return end
    end
    return true
end
</code></pre>
<h3 id="完成基本的socket线程"><a href="#完成基本的socket线程" class="headerlink" title="完成基本的socket线程"></a>完成基本的socket线程</h3><p>经过上述的更改，最终，longlink.lua已经实现了连接服务器并自动处理错误的功能，并且预留了消息接收以及向发送队列添加数据的接口，文件的所有代码如下：</p>
<p>longlink.lua</p>
<pre><code>module(...,package.seeall)
require&quot;socket&quot;
--测试用的服务器信息
local testip,testport = &quot;180.97.81.180&quot;,&quot;50798&quot;
--数据发送的消息队列
local msgQuene = &#123;&#125;
local function insertMsg(data)
    table.insert(msgQuene,data)
end
function waitForSend()
    return #msgQuene &gt; 0
end
function outMsgprocess(socketClient)
    --队列中有消息
    while #msgQuene&gt;0 do
        --获取消息，并从队列中删除
        local outMsg = table.remove(msgQuene,1)
        --发送这条消息，并获取发送结果
        local result = socketClient:send(outMsg)
        --发送失败的话立刻返回nil（等同于false）
        if not result then return end
    end
    return true
end
function inMsgProcess(socketClient)
    local result,data
    while true do
</code></pre>
<p>a</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/697/">上一篇</a>
    

    
    <p>上次更新 2021-01-28</p>
    
    
        <a class="extend next post-next" href="/696/">下一篇</a>
    
    </div>

    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
		
			
				
				<li>
					<a href="https://doc.luatos.wiki/wiki/" title="stack-overflow" target="_self">
					<i class="fa fa-stack-overflow"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/openluat" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © 仅供搜索引擎收录使用 2017 - 2021
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a> & <a target="_blank" rel="noopener" href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
